import streamlit as st
import pandas as pd
from pathlib import Path

# Try to use your helpers; fall back gracefully if not present
try:
    from utils_jobs import (
        load_jobs_active,
        build_job_options,     # we'll still format/pad area ourselves below
        load_cost_options,
    )
    HAVE_UTILS = True
except Exception:
    HAVE_UTILS = False

XLSX = Path(__file__).resolve().parent.parent / "Timesheet Apps.xlsx"

st.markdown("### Timesheet Entry")

# --- Date ---
date_val = st.date_input("Date", value=pd.Timestamp.today().date(), format="YYYY/MM/DD", key="date_val")

# --- Jobs (Active) ---
def _find_col(df: pd.DataFrame, candidates):
    for c in candidates:
        if c in df.columns:
            return c
    return None

def _pad_area(val: object) -> str:
    s = str(val).strip()
    if not s or s.lower() == "nan":
        return ""
    # keep digits; common case is "1" or "1.0"
    import re
    m = re.search(r"\d+", s)
    d = m.group(0) if m else s
    return d.zfill(3)

def _build_job_options_local(df: pd.DataFrame):
    if df is None or df.empty:
        return []
    job_c  = _find_col(df, ["Job Number", "JOB #", "Job #"])
    area_c = _find_col(df, ["Area Number", "AREA #", "Area #"])
    desc_c = _find_col(df, ["Description", "DESCRIPTION", "PROJECT NAME", "Project Name"])
    if not job_c:
        return []
    out = []
    for _, row in df.iterrows():
        j = str(row.get(job_c, "") or "").strip()
        a = _pad_area(row.get(area_c, "")) if area_c else ""
        d = str(row.get(desc_c, "") or "").strip() if desc_c else ""
        if j or a or d:
            out.append(f"{j} - {a} - {d}")
    # unique + sorted
    return sorted(pd.Series(out).dropna().astype(str).unique().tolist())

if HAVE_UTILS:
    jobs_df = load_jobs_active(XLSX)
    job_options = _build_job_options_local(jobs_df)
else:
    # Fallback: read Job Numbers sheet and filter Active == TRUE
    try:
        _df = pd.read_excel(XLSX, sheet_name="Job Numbers")
        _df.columns = [str(c).strip() for c in _df.columns]
        _actcol = _find_col(_df, ["Active"])
        if _actcol:
            _df = _df[_df[_actcol].astype(str).str.upper().isin(["TRUE", "YES", "Y", "1"])]
        job_options = _build_job_options_local(_df)
    except Exception:
        job_options = []

job_choice = st.selectbox(
    "Job Number - Area Number - Description",
    job_options,
    index=None,
    placeholder="Select a jobÃ¢â‚¬Â¦",
)

# --- Cost Codes ---
if HAVE_UTILS:
    cost_options = load_cost_options(XLSX)
else:
    # Fallback: try a standard sheet name
    try:
        _c = pd.read_excel(XLSX, sheet_name="Cost Codes")
        _c.columns = [str(c).strip() for c in _c.columns]
        code_c = _find_col(_c, ["Cost Code", "Code"])
        desc_c = _find_col(_c, ["Description", "DESC", "Name"])
        if code_c:
            if desc_c:
                cost_options = sorted((f"{str(r[code_c]).strip()} - {str(r[desc_c]).strip()}" for _, r in _c.iterrows()))
            else:
                cost_options = sorted((str(r[code_c]).strip() for _, r in _c.iterrows()))
        else:
            cost_options = []
    except Exception:
        cost_options = []

cost_choice = st.selectbox(
    "Cost Code - Description",
    cost_options,
    index=None,
    placeholder="Select a cost codeÃ¢â‚¬Â¦",
)

st.divider()

# --- Employees (multi-select) with auto Night Shift from "Employee List" ---
_emp_df = pd.read_excel(XLSX, sheet_name="Employee List")
_emp_df.columns = [str(c).strip() for c in _emp_df.columns]

# Filter active employees
if "Active" in _emp_df.columns:
    _emp_df = _emp_df[_emp_df["Active"].astype(str).str.upper().isin(["TRUE", "YES", "Y", "1"])]

# Build list of names
EMP_NAME_COL = _find_col(_emp_df, ["Employee Name", "Name"])
if not EMP_NAME_COL:
    EMP_NAME_COL = "Employee Name"  # keep a default to avoid KeyError
    if EMP_NAME_COL not in _emp_df.columns:
        _emp_df[EMP_NAME_COL] = ""

_employee_options = sorted(_emp_df[EMP_NAME_COL].dropna().astype(str).unique().tolist())

selected_employees = st.multiselect(
    "Employees",
    options=_employee_options,
    default=st.session_state.get("selected_employees", []),
    placeholder="Select one or more employeesÃ¢â‚¬Â¦",
)
st.session_state["selected_employees"] = selected_employees

def night_flag_for(_name: str) -> str:
    # Return "Y" or "" based on Employee List column "Night Shift"
    _row = _emp_df.loc[_emp_df[EMP_NAME_COL].astype(str) == str(_name)]
    if _row.empty:
        return ""
    _v = str(_row.iloc[0].get("Night Shift", "")).strip().upper()
    return "Y" if _v in {"Y", "YES", "TRUE", "1"} else ""

cols = st.columns(3)
with cols[0]:
    rt_hours = st.number_input("RT Hours", min_value=0.00, step=0.25, format="%.2f", value=0.00)
with cols[1]:
    ot_hours = st.number_input("OT Hours", min_value=0.00, step=0.25, format="%.2f", value=0.00)
with cols[2]:
    if selected_employees:
        st.caption("Night Shift (auto):")
        for _nm in selected_employees:
            st.write(f"Ã¢â‚¬Â¢ {_nm}: **{'Y' if night_flag_for(_nm) else 'N'}**")

desc_work = st.text_input("Description of work", value="")
comments  = st.text_input("Comments", value="")

# --- Pending rows holder ---
if "pending_rows" not in st.session_state:
    st.session_state["pending_rows"] = []

def _parse_job(choice: str):
    if not choice:
        return "", "", ""
    parts = choice.split(" - ", 2)
    parts += [""] * (3 - len(parts))
    return parts[0], parts[1], parts[2]

# --- Add line (fan-out for each selected employee) ---
add_disabled = not (job_choice and cost_choice and selected_employees and (rt_hours > 0 or ot_hours > 0))
if st.button("Add line", type="primary", disabled=add_disabled):
    job_num, job_area, job_desc = _parse_job(job_choice)
    for _nm in selected_employees:
        _row = _emp_df.loc[_emp_df[EMP_NAME_COL].astype(str) == str(_nm)]
        emp_num = str((_row.iloc[0].get("Person Number") if not _row.empty else "") or "")
        trade   = str((_row.iloc[0].get("Override Trade Class", _row.iloc[0].get("Trade Class")) if not _row.empty else "") or "")
        prem    = str((_row.iloc[0].get("Premium Rate") if not _row.empty else "") or "")
        night   = night_flag_for(_nm)
        st.session_state["pending_rows"].append({
            "Job Number": job_num,
            "Job Area": job_area,
            "Date": pd.to_datetime(date_val).strftime("%Y-%m-%d"),
            "Name": _nm,
            "Trade Class": trade if trade else "",
            "Employee Number": emp_num,
            "RT Hours": rt_hours,
            "OT Hours": ot_hours,
            "Description of work": (desc_work or job_desc),
            "Comments": comments,
            "Night Shift": night,
            "Premium Rate / Subsistence Rate / Travel Rate": prem if prem else "",
            "Cost Code": cost_choice.split(" - ", 1)[0] if cost_choice else "",
        })

# --- Pending table ---
if st.session_state["pending_rows"]:
    df = pd.DataFrame(st.session_state["pending_rows"])
    st.dataframe(df, use_container_width=True, hide_index=True)
if st.session_state.get("pending_rows"):
    import io
    _needed_cols = [
        'Job Number','Job Area','Date','Name','Trade Class','Employee Number',
        'RT Hours','OT Hours','Description of work','Comments','Night Shift',
        'Premium Rate / Subsistence Rate / Travel Rate','Cost Code'
    ]
    _df_dl = pd.DataFrame(st.session_state["pending_rows"])
    # ensure columns exist
    for _c in _needed_cols:
        if _c not in _df_dl.columns:
            _df_dl[_c] = ""
    _buf = io.BytesIO()
    _df_dl[_needed_cols].to_excel(_buf, index=False)
    st.download_button(
        "Download lines as Excel (Time Data)",
        data=_buf.getvalue(),
        file_name="time_data_rows.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        key="dl_time_data_rows"
    )

    def _save_to_time_data(pending: pd.DataFrame):
        needed = [
            "Job Number","Job Area","Date","Name","Class Type","Trade Class",
            "Employee Number","RT Hours","OT Hours","Description of work",
            "Comments","Night Shift","Premium Rate / Subsistence Rate / Travel Rate"
        ]
        try:
            existing = pd.read_excel(XLSX, sheet_name="Time Data")
        except Exception:
            existing = pd.DataFrame(columns=needed)

        # ensure columns
        for c in needed:
            if c not in existing.columns:
                existing[c] = pd.Series(dtype=object)
            if c not in pending.columns:
                pending[c] = ""

        out = pd.concat([existing[needed], pending[needed]], ignore_index=True)
        with pd.ExcelWriter(XLSX, engine="openpyxl", mode="a", if_sheet_exists="replace") as w:
            out.to_excel(w, sheet_name="Time Data", index=False)

    if st.button("Save lines to workbook (Time Data)"):
        try:
            _save_to_time_data(pd.DataFrame(st.session_state["pending_rows"]))
            st.success(f"Saved {len(st.session_state['pending_rows'])} line(s) to 'Time Data'.")
            st.session_state["pending_rows"] = []
        except Exception as e:
            st.error(f"Could not save rows: {e}")
else:
    st.info("Add at least one line above to enable saving.")